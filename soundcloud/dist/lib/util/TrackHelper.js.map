{"version":3,"file":"TrackHelper.js","sourceRoot":"","sources":["../../../src/lib/util/TrackHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import sc from '../SoundCloudContext';\nimport type TrackEntity from '../entities/TrackEntity';\n\n/**\n * Known formats:\n *    preset + protocol | mime type | bitrate\n * 1. aac_160k + hls | audio/mp4 | 160kbps\n * 2. mp3_0_0 + hls | audio/mpeg | 128kbps (URL: https://.../playlist/<uuid>.128.mp3/playlist.m3u8...)\n * 3. mp3_0_0 + progressive (http) | audio/mpeg | 128kbps (URL: https://.../<uuid>.128.mp3?...)\n * 4. opus_0_0 + hls | audio/ogg | 64kbps (URL: https://.../playlist/<uuid>.64.opus//playlist.m3u8...)\n * \n * Preview stream formats:\n * 1. mp3_1_0 + hls | audio/mpeg | 128kbps\n * 2. mp3_1_0 + progressive (http) | audio/mpeg | 128kbps\n * \n * There is also supposedly aac+hls/96kbps and aac+hls/256kbps (Go+), but would need\n * to see how they're actually presented in the API response.\n * \n * According to https://developers.soundcloud.com/blog/api-streaming-urls,\n * the AAC HLS streams will replace all others. Preview (30s) tracks will \n * remain the same (mp3 128kbps progressive).\n */\nconst STREAM_FORMATS = [\n  'aac_160k+hls',\n  'mp3_0_0+http',\n  'opus_0_0+hls',\n  'mp3_0_0+hls',\n  'mp3_1_0+http',\n  'mp3_1_0+hls'\n] as const;\n\ntype StreamFormat = typeof STREAM_FORMATS[number];\n\nconst PREFERRED_STANDARD_STREAM_FORMATS: StreamFormat[] = [\n  'aac_160k+hls',\n  'mp3_0_0+http',\n  'opus_0_0+hls',\n  'mp3_0_0+hls',\n  'mp3_1_0+http',\n  'mp3_1_0+hls'\n];\n\n// Long streams are those >= 30 mins\nconst PREFERRED_LONG_STREAM_FORMAT: StreamFormat[] = [\n  'aac_160k+hls',\n  'opus_0_0+hls',\n  'mp3_0_0+hls',\n  'mp3_1_0+hls',\n  // http streams have ridiculously short expiry\n  // time (~30 mins), so last resort only.\n  'mp3_0_0+http',\n  'mp3_1_0+http',\n];\n\nconst STREAM_FORMAT_DETAILS: Record<\n  StreamFormat,\n  Pick<GetPreferredStreamResult, \"codec\" | \"protocol\" | \"bitrate\">\n> = {\n  'aac_160k+hls': {\n    codec: 'aac',\n    protocol: 'hls',\n    bitrate: '160 kbps'\n  },\n  'mp3_0_0+http': {\n    codec: 'mp3',\n    protocol: 'http',\n    bitrate: '128 kbps'\n  },\n  'opus_0_0+hls': {\n    codec: 'opus',\n    protocol: 'hls',\n    bitrate: '64 kbps'\n  },\n  'mp3_0_0+hls': {\n    codec: 'mp3',\n    protocol: 'hls',\n    bitrate: '128 kbps'\n  },\n  'mp3_1_0+http': {\n    codec: 'mp3',\n    protocol: 'http',\n    bitrate: '128 kbps'\n  },\n  'mp3_1_0+hls': {\n    codec: 'mp3',\n    protocol: 'hls',\n    bitrate: '128 kbps'\n  }\n} as const;\n\nexport interface GetPreferredStreamResult {\n  transcodingUrl: string;\n  format: StreamFormat;\n  codec: 'aac' | 'mp3' | 'opus';\n  protocol: 'hls' | 'http';\n  bitrate: string;\n}\n\ntype StreamFormatMap = Partial<Record<StreamFormat, TrackEntity['transcodings'][number]>>;\n\nexport default class TrackHelper {\n\n  static cacheTracks(tracks: TrackEntity[], cacheKeyGen: (keyData: Record<string, any>) => string) {\n    const cache = sc.getCache();\n    tracks.forEach((track) => {\n      const keyData = { trackId: track.id };\n      const key = cacheKeyGen(keyData);\n      cache.put(key, track);\n    });\n  }\n\n  static getPreferredStream(track: TrackEntity): GetPreferredStreamResult | null {\n    const isLongStream = track.playableState === 'allowed' && track.duration && (track.duration / 1000) > 1800;\n\n    if (sc.getConfigValue('logTranscodings')) {\n      sc.getLogger().info(`[soundcloud-testing] Available transcodings: ${JSON.stringify(track.transcodings)}`);\n    }\n\n    const availableFormats = track.transcodings.reduce<StreamFormatMap>((result, t) => {\n      const protocol = t.protocol === 'progressive' ? 'http' : t.protocol;\n      const sf = `${t.preset}+${protocol}`;\n      if (STREAM_FORMATS.includes(sf as any)) {\n        result[sf as StreamFormat] = t;\n      }\n      return result;\n    }, {});\n\n    let selectedStream: {\n      format: StreamFormat,\n      transcoding: TrackEntity['transcodings'][number]\n    } | null = null;\n    const targetFormats = isLongStream ? PREFERRED_LONG_STREAM_FORMAT : PREFERRED_STANDARD_STREAM_FORMATS;\n    for (const pf of targetFormats) {\n      if (availableFormats[pf]) {\n        selectedStream = {\n          format: pf,\n          transcoding: availableFormats[pf]\n        };\n        break;\n      }\n    }\n\n    let result: GetPreferredStreamResult | null = null;\n\n    if (selectedStream && selectedStream.transcoding.url) {\n      result = {\n        format: selectedStream.format,\n        ...STREAM_FORMAT_DETAILS[selectedStream.format],\n        transcodingUrl: selectedStream.transcoding.url\n      };\n    }\n\n    if (sc.getConfigValue('logTranscodings')) {\n      sc.getLogger().info(`[soundcloud-testing] Chosen transcoding: ${JSON.stringify(result)}`);\n    }\n\n    return result;\n  }\n}\n"]}